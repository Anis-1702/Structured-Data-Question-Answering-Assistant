
import os
import duckdb
from openai import OpenAI
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict
from config import DATA_PATH, OPENAI_API_KEY

client = OpenAI(api_key=OPENAI_API_KEY)

# Connect to in-memory DuckDB and load CSVs as tables
con = duckdb.connect(database=':memory:')
con.sql(f"CREATE TABLE bo AS SELECT * FROM read_csv_auto('{DATA_PATH}/sample_bo_tbl_large.csv', DATEFORMAT='%Y-%m-%d')")
con.sql(f"CREATE TABLE subs AS SELECT * FROM read_csv_auto('{DATA_PATH}/sample_sub_details_large.csv', DATEFORMAT='%Y-%m-%d')")
con.sql(f"CREATE TABLE rev AS SELECT * FROM read_csv_auto('{DATA_PATH}/sample_revenue_large.csv', DATEFORMAT='%Y-%m-%d')")

# Extract column names
bo_cols = [col[0] for col in con.execute("DESCRIBE bo").fetchall()]
subs_cols = [col[0] for col in con.execute("DESCRIBE subs").fetchall()]
rev_cols = [col[0] for col in con.execute("DESCRIBE rev").fetchall()]

class QAState(TypedDict):
    user_query: str
    sql_code: str
    answer: str

def plan_node(state):
    question = state["user_query"]

    prompt = f"""
You are a data analyst assistant. You are provided with three SQL tables: `bo`, `subs`, and `rev`.

Each table has these columns:
- bo: {bo_cols}
- subs: {subs_cols}
- rev: {rev_cols}

Your task:
- Generate a valid DuckDB-compatible SQL query to answer the question below.
- âœ… Do NOT include markdown formatting like ```sql or ``` in the output.
- âœ… Do NOT explain the code â€” only return pure SQL.
- âœ… Assume these tables are already loaded in DuckDB.

Question: {question}
"""

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
    )

    sql_query = response.choices[0].message.content.strip()

    # Remove accidental ```sql markdown
    if sql_query.startswith("```"):
        sql_query = "\n".join(
            line for line in sql_query.splitlines() if not line.strip().startswith("```")
        ).strip()

    if not sql_query:
        state["sql_code"] = "-- ERROR: No SQL generated by model"
    else:
        state["sql_code"] = sql_query

    return state


def execute_code_node(state):
    import duckdb
    import pandas as pd
    import re
    from config import DATA_PATH

    # Load data
    bo = pd.read_csv(f"{DATA_PATH}/sample_bo_tbl_large.csv", parse_dates=["date"])
    subs = pd.read_csv(f"{DATA_PATH}/sample_sub_details_large.csv", parse_dates=["date"])
    rev = pd.read_csv(f"{DATA_PATH}/sample_revenue_large.csv", parse_dates=["date"])

    # Normalize columns
    for df in [bo, subs, rev]:
        df.columns = [col.lower() for col in df.columns]

    # Connect & register dataframes
    con = duckdb.connect()
    con.register("bo", bo)
    con.register("subs", subs)
    con.register("rev", rev)

    try:
        raw_sql = state.get("sql_code") or state.get("sql") or ""
        if not raw_sql.strip():
            raise ValueError("SQL query is empty or not found in state.")

        # Extract SQL between ```sql ... ``` or strip all ```
        cleaned = re.sub(r"```(sql)?", "", raw_sql, flags=re.IGNORECASE).strip()

        # Validate cleaned SQL (basic)
        if not re.match(r"^\s*(SELECT|WITH|INSERT|UPDATE|DELETE|CREATE|DROP)", cleaned, re.IGNORECASE):
            raise ValueError(f"Unrecognized or invalid SQL:\n{cleaned}")

        print("ðŸ§  Executing SQL:\n", cleaned)

        result = con.execute(cleaned).df()

        if result.empty:
            state["answer"] = "âœ… Query executed successfully but returned no rows."
        else:
            state["answer"] = result

    except Exception as e:
        state["answer"] = f"âš ï¸ Error executing SQL: {e}"

    return state



def build_graph():
    graph = StateGraph(QAState)
    graph.add_node("plan", plan_node)
    graph.add_node("execute", execute_code_node)
    graph.set_entry_point("plan")
    graph.add_edge("plan", "execute")
    graph.set_finish_point("execute")
    return graph.compile()

compiled_graph = build_graph()

def ask_question(query: str) -> str:
    init_state: QAState = {"user_query": query, "sql_code": "", "answer": ""}
    final_state = compiled_graph.invoke(init_state)
    return final_state["answer"]
